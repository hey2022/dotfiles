pi = 4*a(1)

define factorial(n) {
	auto ans, i
	if (n < 0) {
		return -1
	}
	ans = 1	
	for (i = 2; i <= n; ++i) {
		ans *= i
	}
	return ans
}

define c(n, r) {
	auto ans, i
	ans = 1
	for (i = 0; i < r; ++i) {
		ans *= n - i
		ans /= i + 1
	}
	return ans
}

define cr(n, r) {
	auto ans, i
	ans = 1
	for (i = 1; i <= r; ++i) {
		ans *= r + n - i
		ans /= i
	}
	return ans
}

define p(n, r) {
	auto ans, i
	ans = 1
	for (i = 0; i < r; ++i) {
		ans *= n - i
	}
	return ans
}

define pr(n, r) {
	return n^r 
}

define void quadratic(a, b, c) {
	auto discriminant
	discriminant = b^2-4*a*c
	print "\\frac{", -b, "+\\sqrt{", discriminant, "}}{", 2*a, "}\n"
	print "\\frac{", -b, "-\\sqrt{", discriminant, "}}{", 2*a, "}\n"
	ans[0] = (-b+sqrt(discriminant))/(2*a)
	ans[1] = (-b-sqrt(discriminant))/(2*a)
}

define slope(x, y, x1, y1) {
	return (y1 - y)/(x1 - x)
}

define pythagoras(a, b) {
	print "\\sqrt{", a^2 + b^2, "}\n"
	return sqrt(a^2 + b^2)
}

define sequence_from_diff(n, differences[], array_size) {
	auto ans, i
	n -= 1
	for (i = 0; i < array_size; ++i) {
		ans += differences[i] * c(n, i)
	}
	return ans
}

define gcd(a, b) {
	if (b == 0) {
		return a
	} else {
		return gcd(b, mod(a, b))
	}
}

define mod(a, b) {
	auto result, tempscale
	tempscale = scale
	scale = 0
	result = a % b
	scale = tempscale
	return result
}

define floor(n) {
	auto tempscale, result
	tempscale = scale
	scale = 0
	result = n / 1
	scale = tempscale
	return result
}

define void to_frac(n) {
	auto precision, tempscale
	precision = 1
	while(n - floor(n) != 0) {
		n *= 10
		precision *= 10
	}
	gcd = gcd(n, precision)
	n /= gcd
	precision /= gcd
	tempscale = scale
	scale = 0
	print "\\frac{", n, "}{", precision, "}\n"
	scale = tempscale
}

define void simplify(a, b) {
	auto gcd, tempscale
	gcd = gcd(a, b)
	tempscale = scale
	scale = 0
	a /= gcd
	b /= gcd
	scale = tempscale
	print "\\frac{", a, "}{", b, "}\n"
}

define round(n) {
	n += 0.5
	return floor(n)
}

define min(a, b) {
	if (a < b) {
		return a
	}
	return b
}

define max(a, b) {
	if (a > b) {
		return a
	}
	return b
}

define lcm(a, b) {
	auto i
	i = max(a, b)
	while (1) {
		if (mod(i, a) == 0 && mod(i, b) == 0) {
			return i
		}
		i += 1
	}
}

define t(theta) {
	return s(theta) / c(theta)
}
